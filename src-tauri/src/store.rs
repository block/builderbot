//! Unified SQLite storage for the application.
//!
//! Single database containing:
//! - Sessions and messages (AI chat conversations)
//! - Projects and artifacts (persistent outputs)

use rusqlite::{params, Connection, OptionalExtension};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::sync::Mutex;

// =============================================================================
// Session Types
// =============================================================================

/// A session (conversation with an AI agent)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Session {
    pub id: String,
    pub working_dir: String,
    pub agent_id: String,
    pub title: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

/// A message in a session
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Message {
    pub id: i64,
    pub session_id: String,
    pub role: MessageRole,
    /// For user messages: plain text
    /// For assistant messages: JSON array of ContentSegment
    pub content: String,
    pub created_at: i64,
}

/// A segment of assistant content (text or tool call), stored in order
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ContentSegment {
    Text {
        text: String,
    },
    ToolCall {
        id: String,
        title: String,
        status: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        locations: Vec<String>,
    },
}

/// Message role
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    User,
    Assistant,
}

impl MessageRole {
    pub fn as_str(&self) -> &'static str {
        match self {
            MessageRole::User => "user",
            MessageRole::Assistant => "assistant",
        }
    }

    pub fn parse(s: &str) -> Self {
        match s {
            "user" => MessageRole::User,
            _ => MessageRole::Assistant,
        }
    }
}

/// Full session with messages
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SessionFull {
    pub session: Session,
    pub messages: Vec<Message>,
}

// =============================================================================
// Project Types
// =============================================================================

/// The generation status of an artifact.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum ArtifactStatus {
    /// Artifact is being generated by AI
    Generating,
    /// Artifact generation completed successfully
    #[default]
    Complete,
    /// Artifact generation failed
    Error,
}

impl ArtifactStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            ArtifactStatus::Generating => "generating",
            ArtifactStatus::Complete => "complete",
            ArtifactStatus::Error => "error",
        }
    }

    pub fn parse(s: &str) -> Self {
        match s {
            "generating" => ArtifactStatus::Generating,
            "error" => ArtifactStatus::Error,
            _ => ArtifactStatus::Complete,
        }
    }
}

/// A goal-oriented collection of artifacts.
/// Note: This is the legacy "Project" for artifacts. See `GitProject` for the new
/// git-integrated project entity that groups branches.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Project {
    pub id: String,
    pub name: String,
    pub created_at: i64,
    pub updated_at: i64,
}

impl Project {
    pub fn new(name: impl Into<String>) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name: name.into(),
            created_at: now,
            updated_at: now,
        }
    }
}

// =============================================================================
// Git Project Types (branch grouping)
// =============================================================================

/// A git project that groups branches together.
/// This replaces the implicit repo_path grouping with an explicit entity
/// that can have settings like subpath for monorepo support.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitProject {
    pub id: String,
    /// Path to the git repository
    pub repo_path: String,
    /// Optional subpath within the repo (for monorepos)
    pub subpath: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

impl GitProject {
    pub fn new(repo_path: impl Into<String>) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            repo_path: repo_path.into(),
            subpath: None,
            created_at: now,
            updated_at: now,
        }
    }

    pub fn with_subpath(mut self, subpath: impl Into<String>) -> Self {
        self.subpath = Some(subpath.into());
        self
    }

    /// Create a GitProject from a database row.
    fn from_row(row: &rusqlite::Row) -> rusqlite::Result<Self> {
        Ok(Self {
            id: row.get(0)?,
            repo_path: row.get(1)?,
            subpath: row.get(2)?,
            created_at: row.get(3)?,
            updated_at: row.get(4)?,
        })
    }

    /// Get the effective working directory for AI sessions.
    /// If subpath is set, returns repo_path/subpath, otherwise just repo_path.
    pub fn effective_cwd(&self, worktree_path: &str) -> String {
        match &self.subpath {
            Some(subpath) if !subpath.is_empty() => {
                format!("{}/{}", worktree_path, subpath)
            }
            _ => worktree_path.to_string(),
        }
    }
}

/// The type of an artifact.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ArtifactType {
    Markdown,
    Commit,
}

impl ArtifactType {
    pub fn as_str(&self) -> &'static str {
        match self {
            ArtifactType::Markdown => "markdown",
            ArtifactType::Commit => "commit",
        }
    }
}

/// Type-specific data for an artifact.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ArtifactData {
    Markdown {
        content: String,
    },
    Commit {
        repo: String,
        branch: String,
        #[serde(rename = "commitSha")]
        commit_sha: String,
    },
}

impl ArtifactData {
    pub fn artifact_type(&self) -> ArtifactType {
        match self {
            ArtifactData::Markdown { .. } => ArtifactType::Markdown,
            ArtifactData::Commit { .. } => ArtifactType::Commit,
        }
    }
}

/// The persistent output of AI work.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Artifact {
    pub id: String,
    pub project_id: String,
    pub title: String,
    pub created_at: i64,
    pub updated_at: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_artifact_id: Option<String>,
    /// The type-specific data (markdown content, commit info, etc.)
    pub data: ArtifactData,
    /// Generation status (generating, complete, error)
    #[serde(default)]
    pub status: ArtifactStatus,
    /// Error message if status is Error
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    /// Session ID for viewing the generation conversation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

impl Artifact {
    /// Create a new markdown artifact.
    pub fn new_markdown(
        project_id: impl Into<String>,
        title: impl Into<String>,
        content: impl Into<String>,
    ) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            project_id: project_id.into(),
            title: title.into(),
            created_at: now,
            updated_at: now,
            parent_artifact_id: None,
            data: ArtifactData::Markdown {
                content: content.into(),
            },
            status: ArtifactStatus::Complete,
            error_message: None,
            session_id: None,
        }
    }

    /// Create a new markdown artifact in generating state.
    pub fn new_generating(project_id: impl Into<String>, title: impl Into<String>) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            project_id: project_id.into(),
            title: title.into(),
            created_at: now,
            updated_at: now,
            parent_artifact_id: None,
            data: ArtifactData::Markdown {
                content: String::new(),
            },
            status: ArtifactStatus::Generating,
            error_message: None,
            session_id: None,
        }
    }

    /// Get the artifact type.
    pub fn artifact_type(&self) -> ArtifactType {
        self.data.artifact_type()
    }
}

// =============================================================================
// Branch Types (git-integrated workflow)
// =============================================================================

/// A tracked branch with an associated worktree.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Branch {
    pub id: String,
    /// The project this branch belongs to
    pub project_id: String,
    /// Path to the original repository
    pub repo_path: String,
    /// Name of the branch (e.g., "feature/auth-flow")
    pub branch_name: String,
    /// Path to the worktree directory
    pub worktree_path: String,
    /// The branch we forked from (for computing diffs)
    pub base_branch: String,
    pub created_at: i64,
    pub updated_at: i64,
}

impl Branch {
    pub fn new(
        project_id: impl Into<String>,
        repo_path: impl Into<String>,
        branch_name: impl Into<String>,
        worktree_path: impl Into<String>,
        base_branch: impl Into<String>,
    ) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            project_id: project_id.into(),
            repo_path: repo_path.into(),
            branch_name: branch_name.into(),
            worktree_path: worktree_path.into(),
            base_branch: base_branch.into(),
            created_at: now,
            updated_at: now,
        }
    }

    /// Create a Branch from a database row.
    fn from_row(row: &rusqlite::Row) -> rusqlite::Result<Self> {
        Ok(Self {
            id: row.get(0)?,
            project_id: row.get(1)?,
            repo_path: row.get(2)?,
            branch_name: row.get(3)?,
            worktree_path: row.get(4)?,
            base_branch: row.get(5)?,
            created_at: row.get(6)?,
            updated_at: row.get(7)?,
        })
    }
}

/// Status of a branch session.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum BranchSessionStatus {
    /// Session is currently running
    Running,
    /// Session completed successfully with a commit
    #[default]
    Completed,
    /// Session encountered an error
    Error,
}

impl BranchSessionStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            BranchSessionStatus::Running => "running",
            BranchSessionStatus::Completed => "completed",
            BranchSessionStatus::Error => "error",
        }
    }

    pub fn parse(s: &str) -> Self {
        match s {
            "running" => BranchSessionStatus::Running,
            "error" => BranchSessionStatus::Error,
            _ => BranchSessionStatus::Completed,
        }
    }
}

/// A session tied to a branch, producing a commit.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct BranchSession {
    pub id: String,
    pub branch_id: String,
    /// The AI session ID (for watching/resuming)
    pub ai_session_id: Option<String>,
    /// The commit SHA produced by this session (null while running)
    pub commit_sha: Option<String>,
    pub status: BranchSessionStatus,
    /// The user's prompt that started this session
    pub prompt: String,
    /// Error message if status is Error
    pub error_message: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

impl BranchSession {
    /// Create a new session in running state.
    pub fn new_running(
        branch_id: impl Into<String>,
        ai_session_id: impl Into<String>,
        prompt: impl Into<String>,
    ) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            branch_id: branch_id.into(),
            ai_session_id: Some(ai_session_id.into()),
            commit_sha: None,
            status: BranchSessionStatus::Running,
            prompt: prompt.into(),
            error_message: None,
            created_at: now,
            updated_at: now,
        }
    }

    /// Create a BranchSession from a database row.
    fn from_row(row: &rusqlite::Row) -> rusqlite::Result<Self> {
        let status_str: String = row.get(4)?;
        Ok(Self {
            id: row.get(0)?,
            branch_id: row.get(1)?,
            ai_session_id: row.get(2)?,
            commit_sha: row.get(3)?,
            status: BranchSessionStatus::parse(&status_str),
            prompt: row.get(5)?,
            error_message: row.get(6)?,
            created_at: row.get(7)?,
            updated_at: row.get(8)?,
        })
    }
}

// =============================================================================
// Branch Note types
// =============================================================================

/// Status of a branch note.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum BranchNoteStatus {
    /// Note is currently being generated
    Generating,
    /// Note generation completed successfully
    #[default]
    Complete,
    /// Note generation encountered an error
    Error,
}

impl BranchNoteStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            BranchNoteStatus::Generating => "generating",
            BranchNoteStatus::Complete => "complete",
            BranchNoteStatus::Error => "error",
        }
    }

    pub fn parse(s: &str) -> Self {
        match s {
            "generating" => BranchNoteStatus::Generating,
            "error" => BranchNoteStatus::Error,
            _ => BranchNoteStatus::Complete,
        }
    }
}

/// A markdown note attached to a branch (AI-generated documentation).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct BranchNote {
    pub id: String,
    pub branch_id: String,
    /// The AI session ID (for viewing the generation conversation)
    pub ai_session_id: Option<String>,
    /// Title of the note
    pub title: String,
    /// Markdown content of the note
    pub content: String,
    pub status: BranchNoteStatus,
    /// The user's prompt that started this note
    pub prompt: String,
    /// Error message if status is Error
    pub error_message: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

impl BranchNote {
    /// Create a new note in generating state.
    pub fn new_generating(
        branch_id: impl Into<String>,
        ai_session_id: impl Into<String>,
        title: impl Into<String>,
        prompt: impl Into<String>,
    ) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            branch_id: branch_id.into(),
            ai_session_id: Some(ai_session_id.into()),
            title: title.into(),
            content: String::new(),
            status: BranchNoteStatus::Generating,
            prompt: prompt.into(),
            error_message: None,
            created_at: now,
            updated_at: now,
        }
    }

    /// Create a BranchNote from a database row.
    fn from_row(row: &rusqlite::Row) -> rusqlite::Result<Self> {
        let status_str: String = row.get(5)?;
        Ok(Self {
            id: row.get(0)?,
            branch_id: row.get(1)?,
            ai_session_id: row.get(2)?,
            title: row.get(3)?,
            content: row.get(4)?,
            status: BranchNoteStatus::parse(&status_str),
            prompt: row.get(6)?,
            error_message: row.get(7)?,
            created_at: row.get(8)?,
            updated_at: row.get(9)?,
        })
    }
}

// =============================================================================
// Error type
// =============================================================================

#[derive(Debug)]
pub struct StoreError(pub String);

impl StoreError {
    pub fn new(msg: impl Into<String>) -> Self {
        Self(msg.into())
    }
}

impl std::fmt::Display for StoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for StoreError {}

impl From<rusqlite::Error> for StoreError {
    fn from(e: rusqlite::Error) -> Self {
        StoreError(e.to_string())
    }
}

impl From<serde_json::Error> for StoreError {
    fn from(e: serde_json::Error) -> Self {
        StoreError(e.to_string())
    }
}

pub type Result<T> = std::result::Result<T, StoreError>;

// =============================================================================
// Store
// =============================================================================

/// Unified SQLite-backed storage
pub struct Store {
    conn: Mutex<Connection>,
}

impl Store {
    /// Open or create the database at the given path
    pub fn open(db_path: PathBuf) -> Result<Self> {
        // Ensure parent directory exists
        if let Some(parent) = db_path.parent() {
            std::fs::create_dir_all(parent)
                .map_err(|e| StoreError::new(format!("Cannot create directory: {}", e)))?;
        }

        let conn = Connection::open(&db_path)?;

        // Enable foreign keys immediately on connection open
        conn.execute("PRAGMA foreign_keys = ON", [])?;

        let store = Self {
            conn: Mutex::new(conn),
        };
        store.init_schema()?;
        Ok(store)
    }

    /// Initialize the database schema
    fn init_schema(&self) -> Result<()> {
        let conn = self.conn.lock().unwrap();

        conn.execute_batch(
            r#"
            -- =================================================================
            -- Sessions (AI chat conversations)
            -- =================================================================

            CREATE TABLE IF NOT EXISTS sessions (
                id TEXT PRIMARY KEY,
                working_dir TEXT NOT NULL,
                agent_id TEXT NOT NULL,
                title TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at INTEGER NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
            CREATE INDEX IF NOT EXISTS idx_sessions_updated ON sessions(updated_at DESC);

            -- =================================================================
            -- Projects and Artifacts
            -- =================================================================

            CREATE TABLE IF NOT EXISTS projects (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE TABLE IF NOT EXISTS artifacts (
                id TEXT PRIMARY KEY,
                project_id TEXT NOT NULL,
                title TEXT NOT NULL,
                artifact_type TEXT NOT NULL,
                data_json TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL,
                parent_artifact_id TEXT,
                status TEXT NOT NULL DEFAULT 'complete',
                error_message TEXT,
                FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
                FOREIGN KEY (parent_artifact_id) REFERENCES artifacts(id) ON DELETE SET NULL
            );

            CREATE TABLE IF NOT EXISTS artifact_context (
                artifact_id TEXT NOT NULL,
                context_artifact_id TEXT NOT NULL,
                PRIMARY KEY (artifact_id, context_artifact_id),
                FOREIGN KEY (artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE,
                FOREIGN KEY (context_artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE
            );

            CREATE INDEX IF NOT EXISTS idx_artifacts_project ON artifacts(project_id);
            CREATE INDEX IF NOT EXISTS idx_artifacts_type ON artifacts(artifact_type);

            -- =================================================================
            -- Branches (git-integrated workflow)
            -- =================================================================

            CREATE TABLE IF NOT EXISTS branches (
                id TEXT PRIMARY KEY,
                repo_path TEXT NOT NULL,
                branch_name TEXT NOT NULL,
                worktree_path TEXT NOT NULL,
                base_branch TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL,
                UNIQUE(repo_path, branch_name)
            );

            CREATE TABLE IF NOT EXISTS branch_sessions (
                id TEXT PRIMARY KEY,
                branch_id TEXT NOT NULL REFERENCES branches(id) ON DELETE CASCADE,
                ai_session_id TEXT,
                commit_sha TEXT,
                status TEXT NOT NULL,
                prompt TEXT NOT NULL,
                error_message TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE TABLE IF NOT EXISTS branch_notes (
                id TEXT PRIMARY KEY,
                branch_id TEXT NOT NULL REFERENCES branches(id) ON DELETE CASCADE,
                ai_session_id TEXT,
                title TEXT NOT NULL,
                content TEXT NOT NULL DEFAULT '',
                status TEXT NOT NULL,
                prompt TEXT NOT NULL,
                error_message TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_branch_sessions_branch ON branch_sessions(branch_id);
            CREATE INDEX IF NOT EXISTS idx_branch_sessions_commit ON branch_sessions(branch_id, commit_sha);
            CREATE INDEX IF NOT EXISTS idx_branches_repo ON branches(repo_path);
            CREATE INDEX IF NOT EXISTS idx_branch_notes_branch ON branch_notes(branch_id);

            -- =================================================================
            -- Git Projects (branch grouping with settings)
            -- =================================================================

            CREATE TABLE IF NOT EXISTS git_projects (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                repo_path TEXT NOT NULL,
                subpath TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_git_projects_repo ON git_projects(repo_path);
            "#,
        )?;

        // Run migrations for existing databases
        Self::run_migrations(&conn)?;

        Ok(())
    }

    /// Run database migrations for schema changes.
    fn run_migrations(conn: &Connection) -> Result<()> {
        // Check if status column exists on artifacts, add if not
        let has_status: bool = conn
            .query_row(
                "SELECT COUNT(*) > 0 FROM pragma_table_info('artifacts') WHERE name = 'status'",
                [],
                |row| row.get(0),
            )
            .unwrap_or(false);

        if !has_status {
            conn.execute(
                "ALTER TABLE artifacts ADD COLUMN status TEXT NOT NULL DEFAULT 'complete'",
                [],
            )?;
            conn.execute("ALTER TABLE artifacts ADD COLUMN error_message TEXT", [])?;
        }

        // Check if session_id column exists on artifacts, add if not
        let has_session_id: bool = conn
            .query_row(
                "SELECT COUNT(*) > 0 FROM pragma_table_info('artifacts') WHERE name = 'session_id'",
                [],
                |row| row.get(0),
            )
            .unwrap_or(false);

        if !has_session_id {
            conn.execute("ALTER TABLE artifacts ADD COLUMN session_id TEXT", [])?;
        }

        // Check if ai_session_id column exists on branch_sessions, add if not
        let has_ai_session_id: bool = conn
            .query_row(
                "SELECT COUNT(*) > 0 FROM pragma_table_info('branch_sessions') WHERE name = 'ai_session_id'",
                [],
                |row| row.get(0),
            )
            .unwrap_or(false);

        if !has_ai_session_id {
            conn.execute(
                "ALTER TABLE branch_sessions ADD COLUMN ai_session_id TEXT",
                [],
            )?;
        }

        // Check if project_id column exists on branches, add if not
        let has_project_id: bool = conn
            .query_row(
                "SELECT COUNT(*) > 0 FROM pragma_table_info('branches') WHERE name = 'project_id'",
                [],
                |row| row.get(0),
            )
            .unwrap_or(false);

        if !has_project_id {
            // Add project_id column
            conn.execute("ALTER TABLE branches ADD COLUMN project_id TEXT", [])?;

            // For each existing branch, get or create a project for its repo_path
            let mut stmt =
                conn.prepare("SELECT id, repo_path FROM branches WHERE project_id IS NULL")?;
            let branch_repos: Vec<(String, String)> = stmt
                .query_map([], |row| Ok((row.get(0)?, row.get(1)?)))?
                .collect::<rusqlite::Result<_>>()?;

            for (branch_id, repo_path) in branch_repos {
                // Check if a project exists for this repo_path
                let project_id: Option<String> = conn
                    .query_row(
                        "SELECT id FROM git_projects WHERE repo_path = ?1 AND subpath IS NULL LIMIT 1",
                        params![&repo_path],
                        |row| row.get(0),
                    )
                    .optional()?;

                let project_id = if let Some(pid) = project_id {
                    pid
                } else {
                    // Create a new project for this repo
                    let new_project_id = uuid::Uuid::new_v4().to_string();
                    let now = now_timestamp();
                    conn.execute(
                        "INSERT INTO git_projects (id, name, repo_path, subpath, created_at, updated_at)
                         VALUES (?1, '', ?2, NULL, ?3, ?4)",
                        params![&new_project_id, &repo_path, now, now],
                    )?;
                    new_project_id
                };

                // Update the branch with the project_id
                conn.execute(
                    "UPDATE branches SET project_id = ?1 WHERE id = ?2",
                    params![&project_id, &branch_id],
                )?;
            }
        }

        Ok(())
    }

    // =========================================================================
    // Session operations
    // =========================================================================

    /// Create a new session
    pub fn create_session(&self, session: &Session) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO sessions (id, working_dir, agent_id, title, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
            params![
                &session.id,
                &session.working_dir,
                &session.agent_id,
                &session.title,
                session.created_at,
                session.updated_at,
            ],
        )?;
        Ok(())
    }

    /// Get a session by ID
    pub fn get_session(&self, id: &str) -> Result<Option<Session>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, working_dir, agent_id, title, created_at, updated_at
             FROM sessions WHERE id = ?1",
            params![id],
            |row| {
                Ok(Session {
                    id: row.get(0)?,
                    working_dir: row.get(1)?,
                    agent_id: row.get(2)?,
                    title: row.get(3)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                })
            },
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all sessions, ordered by most recently updated
    pub fn list_sessions(&self) -> Result<Vec<Session>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, working_dir, agent_id, title, created_at, updated_at
             FROM sessions ORDER BY updated_at DESC",
        )?;
        let sessions = stmt
            .query_map([], |row| {
                Ok(Session {
                    id: row.get(0)?,
                    working_dir: row.get(1)?,
                    agent_id: row.get(2)?,
                    title: row.get(3)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(sessions)
    }

    /// List sessions for a specific working directory
    pub fn list_sessions_for_dir(&self, working_dir: &str) -> Result<Vec<Session>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, working_dir, agent_id, title, created_at, updated_at
             FROM sessions WHERE working_dir = ?1 ORDER BY updated_at DESC",
        )?;
        let sessions = stmt
            .query_map(params![working_dir], |row| {
                Ok(Session {
                    id: row.get(0)?,
                    working_dir: row.get(1)?,
                    agent_id: row.get(2)?,
                    title: row.get(3)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(sessions)
    }

    /// Update session title
    pub fn update_session_title(&self, id: &str, title: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE sessions SET title = ?1, updated_at = ?2 WHERE id = ?3",
            params![title, now, id],
        )?;
        Ok(())
    }

    /// Touch session (update updated_at)
    pub fn touch_session(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE sessions SET updated_at = ?1 WHERE id = ?2",
            params![now, id],
        )?;
        Ok(())
    }

    /// Delete a session and all its messages
    pub fn delete_session(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM sessions WHERE id = ?1", params![id])?;
        Ok(())
    }

    // =========================================================================
    // Message operations
    // =========================================================================

    /// Add a message to a session, returns the message ID
    pub fn add_message(&self, session_id: &str, role: MessageRole, content: &str) -> Result<i64> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();

        conn.execute(
            "INSERT INTO messages (session_id, role, content, created_at)
             VALUES (?1, ?2, ?3, ?4)",
            params![session_id, role.as_str(), content, now],
        )?;

        let message_id = conn.last_insert_rowid();

        // Update session's updated_at
        conn.execute(
            "UPDATE sessions SET updated_at = ?1 WHERE id = ?2",
            params![now, session_id],
        )?;

        Ok(message_id)
    }

    /// Get all messages for a session
    pub fn get_messages(&self, session_id: &str) -> Result<Vec<Message>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, session_id, role, content, created_at
             FROM messages WHERE session_id = ?1 ORDER BY id ASC",
        )?;
        let messages = stmt
            .query_map(params![session_id], |row| {
                let role_str: String = row.get(2)?;
                Ok(Message {
                    id: row.get(0)?,
                    session_id: row.get(1)?,
                    role: MessageRole::parse(&role_str),
                    content: row.get(3)?,
                    created_at: row.get(4)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(messages)
    }

    /// Get full session with all messages
    pub fn get_session_full(&self, id: &str) -> Result<Option<SessionFull>> {
        let session = match self.get_session(id)? {
            Some(s) => s,
            None => return Ok(None),
        };

        let messages = self.get_messages(id)?;
        Ok(Some(SessionFull { session, messages }))
    }

    /// Add an assistant turn with ordered segments (text + tool calls interleaved)
    pub fn add_assistant_turn(&self, session_id: &str, segments: &[ContentSegment]) -> Result<i64> {
        let content = serde_json::to_string(segments)?;
        self.add_message(session_id, MessageRole::Assistant, &content)
    }

    // =========================================================================
    // Project operations
    // =========================================================================

    /// Create a new project.
    pub fn create_project(&self, project: &Project) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO projects (id, name, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
            params![
                &project.id,
                &project.name,
                &project.created_at,
                &project.updated_at
            ],
        )?;
        Ok(())
    }

    /// Get a project by ID.
    pub fn get_project(&self, id: &str) -> Result<Option<Project>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, name, created_at, updated_at FROM projects WHERE id = ?1",
            params![id],
            |row| {
                Ok(Project {
                    id: row.get(0)?,
                    name: row.get(1)?,
                    created_at: row.get(2)?,
                    updated_at: row.get(3)?,
                })
            },
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all projects, ordered by most recently updated.
    pub fn list_projects(&self) -> Result<Vec<Project>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, name, created_at, updated_at FROM projects ORDER BY updated_at DESC",
        )?;
        let projects = stmt
            .query_map([], |row| {
                Ok(Project {
                    id: row.get(0)?,
                    name: row.get(1)?,
                    created_at: row.get(2)?,
                    updated_at: row.get(3)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(projects)
    }

    /// Update a project's name.
    pub fn update_project(&self, id: &str, name: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE projects SET name = ?1, updated_at = ?2 WHERE id = ?3",
            params![name, now, id],
        )?;
        Ok(())
    }

    /// Delete a project and all its artifacts.
    pub fn delete_project(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM projects WHERE id = ?1", params![id])?;
        Ok(())
    }

    // =========================================================================
    // Artifact operations
    // =========================================================================

    /// Create a new artifact.
    pub fn create_artifact(&self, artifact: &Artifact) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let data_json =
            serde_json::to_string(&artifact.data).map_err(|e| StoreError::new(e.to_string()))?;

        conn.execute(
            "INSERT INTO artifacts (id, project_id, title, artifact_type, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)",
            params![
                &artifact.id,
                &artifact.project_id,
                &artifact.title,
                artifact.artifact_type().as_str(),
                data_json,
                &artifact.created_at,
                &artifact.updated_at,
                &artifact.parent_artifact_id,
                artifact.status.as_str(),
                &artifact.error_message,
                &artifact.session_id,
            ],
        )?;

        // Update the project's updated_at timestamp
        let now = now_timestamp();
        conn.execute(
            "UPDATE projects SET updated_at = ?1 WHERE id = ?2",
            params![now, &artifact.project_id],
        )?;

        Ok(())
    }

    /// Get an artifact by ID.
    pub fn get_artifact(&self, id: &str) -> Result<Option<Artifact>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, project_id, title, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id
             FROM artifacts WHERE id = ?1",
            params![id],
            |row| {
                let data_json: String = row.get(3)?;
                let data: ArtifactData = serde_json::from_str(&data_json).map_err(|e| {
                    rusqlite::Error::FromSqlConversionFailure(
                        3,
                        rusqlite::types::Type::Text,
                        Box::new(e),
                    )
                })?;
                let status_str: String = row.get(7)?;
                Ok(Artifact {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    title: row.get(2)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                    parent_artifact_id: row.get(6)?,
                    data,
                    status: ArtifactStatus::parse(&status_str),
                    error_message: row.get(8)?,
                    session_id: row.get(9)?,
                })
            },
        )
        .optional()
        .map_err(Into::into)
    }

    /// List artifacts in a project, ordered by most recently updated.
    pub fn list_artifacts(&self, project_id: &str) -> Result<Vec<Artifact>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, title, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id
             FROM artifacts WHERE project_id = ?1 ORDER BY updated_at DESC",
        )?;
        let artifacts = stmt
            .query_map(params![project_id], |row| {
                let data_json: String = row.get(3)?;
                let data: ArtifactData = serde_json::from_str(&data_json).map_err(|e| {
                    rusqlite::Error::FromSqlConversionFailure(
                        3,
                        rusqlite::types::Type::Text,
                        Box::new(e),
                    )
                })?;
                let status_str: String = row.get(7)?;
                Ok(Artifact {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    title: row.get(2)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                    parent_artifact_id: row.get(6)?,
                    data,
                    status: ArtifactStatus::parse(&status_str),
                    error_message: row.get(8)?,
                    session_id: row.get(9)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(artifacts)
    }

    /// List artifacts by type in a project.
    #[allow(dead_code)]
    pub fn list_artifacts_by_type(
        &self,
        project_id: &str,
        artifact_type: ArtifactType,
    ) -> Result<Vec<Artifact>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, title, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id
             FROM artifacts WHERE project_id = ?1 AND artifact_type = ?2 ORDER BY updated_at DESC",
        )?;
        let artifacts = stmt
            .query_map(params![project_id, artifact_type.as_str()], |row| {
                let data_json: String = row.get(3)?;
                let data: ArtifactData = serde_json::from_str(&data_json).map_err(|e| {
                    rusqlite::Error::FromSqlConversionFailure(
                        3,
                        rusqlite::types::Type::Text,
                        Box::new(e),
                    )
                })?;
                let status_str: String = row.get(7)?;
                Ok(Artifact {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    title: row.get(2)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                    parent_artifact_id: row.get(6)?,
                    data,
                    status: ArtifactStatus::parse(&status_str),
                    error_message: row.get(8)?,
                    session_id: row.get(9)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(artifacts)
    }

    /// Update an artifact's title and/or content.
    pub fn update_artifact(
        &self,
        id: &str,
        title: Option<&str>,
        data: Option<&ArtifactData>,
    ) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();

        match (title, data) {
            (Some(title), Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET title = ?1, data_json = ?2, artifact_type = ?3, updated_at = ?4 WHERE id = ?5",
                    params![title, data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (Some(title), None) => {
                conn.execute(
                    "UPDATE artifacts SET title = ?1, updated_at = ?2 WHERE id = ?3",
                    params![title, now, id],
                )?;
            }
            (None, Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET data_json = ?1, artifact_type = ?2, updated_at = ?3 WHERE id = ?4",
                    params![data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (None, None) => {
                return Ok(());
            }
        }

        // Update the project's updated_at timestamp
        conn.execute(
            "UPDATE projects SET updated_at = ?1 WHERE id = (SELECT project_id FROM artifacts WHERE id = ?2)",
            params![now, id],
        )?;

        Ok(())
    }

    /// Update an artifact's status (and optionally content/title).
    pub fn update_artifact_status(
        &self,
        id: &str,
        status: ArtifactStatus,
        error_message: Option<&str>,
        title: Option<&str>,
        data: Option<&ArtifactData>,
    ) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();

        match (title, data) {
            (Some(title), Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, title = ?3, data_json = ?4, artifact_type = ?5, updated_at = ?6 WHERE id = ?7",
                    params![status.as_str(), error_message, title, data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (Some(title), None) => {
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, title = ?3, updated_at = ?4 WHERE id = ?5",
                    params![status.as_str(), error_message, title, now, id],
                )?;
            }
            (None, Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, data_json = ?3, artifact_type = ?4, updated_at = ?5 WHERE id = ?6",
                    params![status.as_str(), error_message, data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (None, None) => {
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, updated_at = ?3 WHERE id = ?4",
                    params![status.as_str(), error_message, now, id],
                )?;
            }
        }

        Ok(())
    }

    /// Delete an artifact.
    pub fn delete_artifact(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM artifacts WHERE id = ?1", params![id])?;
        Ok(())
    }

    /// Set the session ID for an artifact.
    pub fn set_artifact_session(&self, artifact_id: &str, session_id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE artifacts SET session_id = ?1, updated_at = ?2 WHERE id = ?3",
            params![session_id, now, artifact_id],
        )?;
        Ok(())
    }

    // =========================================================================
    // Context operations
    // =========================================================================

    /// Add a context link (artifact X was created using artifact Y as context).
    pub fn add_context(&self, artifact_id: &str, context_artifact_id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT OR IGNORE INTO artifact_context (artifact_id, context_artifact_id) VALUES (?1, ?2)",
            params![artifact_id, context_artifact_id],
        )?;
        Ok(())
    }

    /// Get the artifacts that were used as context when creating an artifact.
    pub fn get_context_artifacts(&self, artifact_id: &str) -> Result<Vec<String>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn
            .prepare("SELECT context_artifact_id FROM artifact_context WHERE artifact_id = ?1")?;
        let ids = stmt
            .query_map(params![artifact_id], |row| row.get(0))?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(ids)
    }

    /// Get the artifacts that use this artifact as context.
    #[allow(dead_code)]
    pub fn get_dependent_artifacts(&self, context_artifact_id: &str) -> Result<Vec<String>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn
            .prepare("SELECT artifact_id FROM artifact_context WHERE context_artifact_id = ?1")?;
        let ids = stmt
            .query_map(params![context_artifact_id], |row| row.get(0))?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(ids)
    }

    // =========================================================================
    // Branch operations
    // =========================================================================

    /// Create a new branch
    pub fn create_branch(&self, branch: &Branch) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO branches (id, project_id, repo_path, branch_name, worktree_path, base_branch, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)",
            params![
                &branch.id,
                &branch.project_id,
                &branch.repo_path,
                &branch.branch_name,
                &branch.worktree_path,
                &branch.base_branch,
                branch.created_at,
                branch.updated_at,
            ],
        )?;
        Ok(())
    }

    /// Get a branch by ID
    pub fn get_branch(&self, id: &str) -> Result<Option<Branch>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, project_id, repo_path, branch_name, worktree_path, base_branch, created_at, updated_at
             FROM branches WHERE id = ?1",
            params![id],
            Branch::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all branches, ordered by most recently updated
    pub fn list_branches(&self) -> Result<Vec<Branch>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, repo_path, branch_name, worktree_path, base_branch, created_at, updated_at
             FROM branches ORDER BY updated_at DESC",
        )?;
        let branches = stmt
            .query_map([], Branch::from_row)?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(branches)
    }

    /// List branches for a specific repository
    pub fn list_branches_for_repo(&self, repo_path: &str) -> Result<Vec<Branch>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, repo_path, branch_name, worktree_path, base_branch, created_at, updated_at
             FROM branches WHERE repo_path = ?1 ORDER BY updated_at DESC",
        )?;
        let branches = stmt
            .query_map(params![repo_path], Branch::from_row)?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(branches)
    }

    /// List branches for a specific project
    pub fn list_branches_for_project(&self, project_id: &str) -> Result<Vec<Branch>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, repo_path, branch_name, worktree_path, base_branch, created_at, updated_at
             FROM branches WHERE project_id = ?1 ORDER BY updated_at DESC",
        )?;
        let branches = stmt
            .query_map(params![project_id], Branch::from_row)?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(branches)
    }

    /// Delete a branch and all its sessions
    pub fn delete_branch(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM branches WHERE id = ?1", params![id])?;
        Ok(())
    }

    /// Touch branch (update updated_at)
    pub fn touch_branch(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE branches SET updated_at = ?1 WHERE id = ?2",
            params![now, id],
        )?;
        Ok(())
    }

    /// Update a branch's base branch
    pub fn update_branch_base(&self, id: &str, base_branch: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE branches SET base_branch = ?1, updated_at = ?2 WHERE id = ?3",
            params![base_branch, now, id],
        )?;
        Ok(())
    }

    // =========================================================================
    // Branch session operations
    // =========================================================================

    /// Create a new branch session
    pub fn create_branch_session(&self, session: &BranchSession) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO branch_sessions (id, branch_id, ai_session_id, commit_sha, status, prompt, error_message, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)",
            params![
                &session.id,
                &session.branch_id,
                &session.ai_session_id,
                &session.commit_sha,
                session.status.as_str(),
                &session.prompt,
                &session.error_message,
                session.created_at,
                session.updated_at,
            ],
        )?;

        // Also touch the branch
        let now = now_timestamp();
        conn.execute(
            "UPDATE branches SET updated_at = ?1 WHERE id = ?2",
            params![now, &session.branch_id],
        )?;

        Ok(())
    }

    /// Get a branch session by ID
    pub fn get_branch_session(&self, id: &str) -> Result<Option<BranchSession>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, commit_sha, status, prompt, error_message, created_at, updated_at
             FROM branch_sessions WHERE id = ?1",
            params![id],
            BranchSession::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all sessions for a branch
    pub fn list_branch_sessions(&self, branch_id: &str) -> Result<Vec<BranchSession>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, branch_id, ai_session_id, commit_sha, status, prompt, error_message, created_at, updated_at
             FROM branch_sessions WHERE branch_id = ?1 ORDER BY created_at ASC",
        )?;
        let sessions = stmt
            .query_map(params![branch_id], BranchSession::from_row)?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(sessions)
    }

    /// Find the session for a specific commit on a branch
    pub fn get_session_for_commit(
        &self,
        branch_id: &str,
        commit_sha: &str,
    ) -> Result<Option<BranchSession>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, commit_sha, status, prompt, error_message, created_at, updated_at
             FROM branch_sessions WHERE branch_id = ?1 AND commit_sha = ?2",
            params![branch_id, commit_sha],
            BranchSession::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Get the currently running session for a branch (if any)
    pub fn get_running_session(&self, branch_id: &str) -> Result<Option<BranchSession>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, commit_sha, status, prompt, error_message, created_at, updated_at
             FROM branch_sessions WHERE branch_id = ?1 AND status = 'running'",
            params![branch_id],
            BranchSession::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Get a branch session by its AI session ID
    pub fn get_branch_session_by_ai_session(
        &self,
        ai_session_id: &str,
    ) -> Result<Option<BranchSession>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, commit_sha, status, prompt, error_message, created_at, updated_at
             FROM branch_sessions WHERE ai_session_id = ?1",
            params![ai_session_id],
            BranchSession::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Update a branch session's status and commit SHA
    pub fn update_branch_session_completed(&self, id: &str, commit_sha: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE branch_sessions SET status = 'completed', commit_sha = ?1, updated_at = ?2 WHERE id = ?3",
            params![commit_sha, now, id],
        )?;
        Ok(())
    }

    /// Update a branch session to error state
    pub fn update_branch_session_error(&self, id: &str, error_message: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE branch_sessions SET status = 'error', error_message = ?1, updated_at = ?2 WHERE id = ?3",
            params![error_message, now, id],
        )?;
        Ok(())
    }

    /// Delete a branch session
    pub fn delete_branch_session(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM branch_sessions WHERE id = ?1", params![id])?;
        Ok(())
    }

    // =========================================================================
    // Branch note operations
    // =========================================================================

    /// Create a new branch note
    pub fn create_branch_note(&self, note: &BranchNote) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO branch_notes (id, branch_id, ai_session_id, title, content, status, prompt, error_message, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)",
            params![
                &note.id,
                &note.branch_id,
                &note.ai_session_id,
                &note.title,
                &note.content,
                note.status.as_str(),
                &note.prompt,
                &note.error_message,
                note.created_at,
                note.updated_at,
            ],
        )?;

        // Also touch the branch
        let now = now_timestamp();
        conn.execute(
            "UPDATE branches SET updated_at = ?1 WHERE id = ?2",
            params![now, &note.branch_id],
        )?;

        Ok(())
    }

    /// Get a branch note by ID
    pub fn get_branch_note(&self, id: &str) -> Result<Option<BranchNote>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, title, content, status, prompt, error_message, created_at, updated_at
             FROM branch_notes WHERE id = ?1",
            params![id],
            BranchNote::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all notes for a branch, ordered by creation time
    pub fn list_branch_notes(&self, branch_id: &str) -> Result<Vec<BranchNote>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, branch_id, ai_session_id, title, content, status, prompt, error_message, created_at, updated_at
             FROM branch_notes WHERE branch_id = ?1 ORDER BY created_at ASC",
        )?;
        let notes = stmt
            .query_map(params![branch_id], BranchNote::from_row)?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(notes)
    }

    /// Get a branch note by its AI session ID
    pub fn get_branch_note_by_ai_session(&self, ai_session_id: &str) -> Result<Option<BranchNote>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, title, content, status, prompt, error_message, created_at, updated_at
             FROM branch_notes WHERE ai_session_id = ?1",
            params![ai_session_id],
            BranchNote::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Get the currently generating note for a branch (if any)
    pub fn get_generating_note(&self, branch_id: &str) -> Result<Option<BranchNote>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, branch_id, ai_session_id, title, content, status, prompt, error_message, created_at, updated_at
             FROM branch_notes WHERE branch_id = ?1 AND status = 'generating'",
            params![branch_id],
            BranchNote::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Update a branch note's content and mark as complete
    pub fn update_branch_note_completed(&self, id: &str, content: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE branch_notes SET status = 'complete', content = ?1, updated_at = ?2 WHERE id = ?3",
            params![content, now, id],
        )?;
        Ok(())
    }

    /// Update a branch note to error state
    pub fn update_branch_note_error(&self, id: &str, error_message: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE branch_notes SET status = 'error', error_message = ?1, updated_at = ?2 WHERE id = ?3",
            params![error_message, now, id],
        )?;
        Ok(())
    }

    /// Delete a branch note
    pub fn delete_branch_note(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM branch_notes WHERE id = ?1", params![id])?;
        Ok(())
    }

    // =========================================================================
    // Git Project operations
    // =========================================================================

    /// Create a new git project
    pub fn create_git_project(&self, project: &GitProject) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO git_projects (id, name, repo_path, subpath, created_at, updated_at)
             VALUES (?1, '', ?2, ?3, ?4, ?5)",
            params![
                &project.id,
                &project.repo_path,
                &project.subpath,
                project.created_at,
                project.updated_at,
            ],
        )?;
        Ok(())
    }

    /// Get a git project by ID
    pub fn get_git_project(&self, id: &str) -> Result<Option<GitProject>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, repo_path, subpath, created_at, updated_at
             FROM git_projects WHERE id = ?1",
            params![id],
            GitProject::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Get a git project by repo_path
    pub fn get_git_project_by_repo(&self, repo_path: &str) -> Result<Option<GitProject>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, repo_path, subpath, created_at, updated_at
             FROM git_projects WHERE repo_path = ?1",
            params![repo_path],
            GitProject::from_row,
        )
        .optional()
        .map_err(Into::into)
    }

    /// Get a git project by repo_path and subpath (exact match, NULL-safe)
    pub fn get_git_project_by_repo_and_subpath(
        &self,
        repo_path: &str,
        subpath: Option<&str>,
    ) -> Result<Option<GitProject>> {
        let conn = self.conn.lock().unwrap();

        // Use explicit NULL check or equality depending on subpath value
        // This avoids potential issues with the IS operator and bound parameters
        let result = match subpath {
            None => conn.query_row(
                "SELECT id, repo_path, subpath, created_at, updated_at
                     FROM git_projects WHERE repo_path = ?1 AND subpath IS NULL",
                params![repo_path],
                GitProject::from_row,
            ),
            Some(sp) => conn.query_row(
                "SELECT id, repo_path, subpath, created_at, updated_at
                     FROM git_projects WHERE repo_path = ?1 AND subpath = ?2",
                params![repo_path, sp],
                GitProject::from_row,
            ),
        };

        result.optional().map_err(Into::into)
    }

    /// List all git projects, ordered by most recently updated
    pub fn list_git_projects(&self) -> Result<Vec<GitProject>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, repo_path, subpath, created_at, updated_at
             FROM git_projects ORDER BY updated_at DESC",
        )?;
        let projects = stmt
            .query_map([], GitProject::from_row)?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(projects)
    }

    /// Update a git project's subpath
    pub fn update_git_project(&self, id: &str, subpath: Option<&str>) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE git_projects SET subpath = ?1, updated_at = ?2 WHERE id = ?3",
            params![subpath, now, id],
        )?;
        Ok(())
    }

    /// Delete a git project
    /// Note: This does NOT cascade to branches - branches still reference repo_path directly
    pub fn delete_git_project(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM git_projects WHERE id = ?1", params![id])?;
        Ok(())
    }

    /// Touch git project (update updated_at)
    pub fn touch_git_project(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE git_projects SET updated_at = ?1 WHERE id = ?2",
            params![now, id],
        )?;
        Ok(())
    }
}

// =============================================================================
// Helpers
// =============================================================================

/// Get current timestamp in milliseconds
pub fn now_timestamp() -> i64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis() as i64
}

/// Generate a unique session ID
pub fn generate_session_id() -> String {
    let timestamp = now_timestamp();
    static COUNTER: std::sync::atomic::AtomicU32 = std::sync::atomic::AtomicU32::new(0);
    let count = COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    format!("session_{:x}_{:x}", timestamp, count)
}

// =============================================================================
// Global Store
// =============================================================================

use std::sync::OnceLock;
use tauri::{AppHandle, Manager};

/// Global store instance - initialized during app setup.
static STORE: OnceLock<std::result::Result<Store, String>> = OnceLock::new();

/// Initialize the global store with the app's data directory.
/// Call this once during Tauri app setup.
pub fn init_store(app_handle: &AppHandle) -> Result<()> {
    let app_data_dir = app_handle
        .path()
        .app_data_dir()
        .map_err(|e| StoreError::new(format!("Cannot get app data dir: {}", e)))?;

    let db_path = app_data_dir.join("data.db");

    STORE.get_or_init(|| Store::open(db_path).map_err(|e| e.0));

    // Check if initialization succeeded
    get_store()?;
    Ok(())
}

/// Get the global store. Must call init_store first during app setup.
pub fn get_store() -> Result<&'static Store> {
    let result = STORE
        .get()
        .ok_or_else(|| StoreError::new("Store not initialized"))?;

    match result {
        Ok(store) => Ok(store),
        Err(msg) => Err(StoreError::new(msg.clone())),
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_create_and_get_session() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: Some("Test Session".to_string()),
            created_at: now,
            updated_at: now,
        };

        store.create_session(&session).unwrap();
        let retrieved = store.get_session("test-session").unwrap().unwrap();

        assert_eq!(retrieved.id, "test-session");
        assert_eq!(retrieved.title, Some("Test Session".to_string()));
    }

    #[test]
    fn test_add_and_get_messages() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: None,
            created_at: now,
            updated_at: now,
        };
        store.create_session(&session).unwrap();

        store
            .add_message("test-session", MessageRole::User, "Hello")
            .unwrap();
        store
            .add_message("test-session", MessageRole::Assistant, "Hi there!")
            .unwrap();

        let messages = store.get_messages("test-session").unwrap();
        assert_eq!(messages.len(), 2);
        assert_eq!(messages[0].role, MessageRole::User);
        assert_eq!(messages[0].content, "Hello");
        assert_eq!(messages[1].role, MessageRole::Assistant);
    }

    #[test]
    fn test_assistant_segments() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: None,
            created_at: now,
            updated_at: now,
        };
        store.create_session(&session).unwrap();

        let segments = vec![
            ContentSegment::Text {
                text: "Let me read that file.".to_string(),
            },
            ContentSegment::ToolCall {
                id: "tc1".to_string(),
                title: "Read file".to_string(),
                status: "completed".to_string(),
                locations: vec!["src/main.rs".to_string()],
            },
            ContentSegment::Text {
                text: "Here's what I found.".to_string(),
            },
        ];

        store
            .add_message("test-session", MessageRole::User, "Read main.rs")
            .unwrap();
        store.add_assistant_turn("test-session", &segments).unwrap();

        let full = store.get_session_full("test-session").unwrap().unwrap();
        assert_eq!(full.messages.len(), 2);

        let loaded_segments: Vec<ContentSegment> =
            serde_json::from_str(&full.messages[1].content).unwrap();
        assert_eq!(loaded_segments.len(), 3);
    }

    #[test]
    fn test_delete_session_cascades() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: None,
            created_at: now,
            updated_at: now,
        };
        store.create_session(&session).unwrap();
        store
            .add_message("test-session", MessageRole::User, "Hello")
            .unwrap();

        store.delete_session("test-session").unwrap();

        let retrieved = store.get_session("test-session").unwrap();
        assert!(retrieved.is_none());

        let messages = store.get_messages("test-session").unwrap();
        assert!(messages.is_empty());
    }

    #[test]
    fn test_create_and_get_project() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");

        store.create_project(&project).unwrap();
        let retrieved = store.get_project(&project.id).unwrap().unwrap();

        assert_eq!(retrieved.id, project.id);
        assert_eq!(retrieved.name, "Test Project");
    }

    #[test]
    fn test_create_and_get_artifact() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");
        store.create_project(&project).unwrap();

        let artifact = Artifact::new_markdown(&project.id, "Test Artifact", "# Hello\n\nWorld");
        store.create_artifact(&artifact).unwrap();

        let retrieved = store.get_artifact(&artifact.id).unwrap().unwrap();
        assert_eq!(retrieved.id, artifact.id);
        assert_eq!(retrieved.title, "Test Artifact");

        if let ArtifactData::Markdown { content } = &retrieved.data {
            assert_eq!(content, "# Hello\n\nWorld");
        } else {
            panic!("Expected markdown artifact");
        }
    }

    #[test]
    fn test_delete_project_cascades() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");
        store.create_project(&project).unwrap();

        let artifact = Artifact::new_markdown(&project.id, "Test", "Content");
        store.create_artifact(&artifact).unwrap();

        store.delete_project(&project.id).unwrap();

        let retrieved = store.get_artifact(&artifact.id).unwrap();
        assert!(retrieved.is_none());
    }

    #[test]
    fn test_context_links() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");
        store.create_project(&project).unwrap();

        let a1 = Artifact::new_markdown(&project.id, "Research", "Research content");
        let a2 = Artifact::new_markdown(&project.id, "Plan", "Plan based on research");

        store.create_artifact(&a1).unwrap();
        store.create_artifact(&a2).unwrap();

        store.add_context(&a2.id, &a1.id).unwrap();

        let context = store.get_context_artifacts(&a2.id).unwrap();
        assert_eq!(context, vec![a1.id.clone()]);

        let dependents = store.get_dependent_artifacts(&a1.id).unwrap();
        assert_eq!(dependents, vec![a2.id.clone()]);
    }
}
